[{"title":"CF2169C","url":"/2025/12/15/CF2169C/","content":" Problem - C - Codeforces \n这题有2个解法，然而我赛时一个没写出来，这不是废物是什么？\n解法一对于任意区间 [L,R]：\n\\Delta = (R-L+1)(L+R) - (pre[R]-pre[L-1])换算一下，得到：\n\\Delta =(R^2+R−pre[R])+(pre[L−1]−(L^2−L))注意到\n\\Delta = \\underbrace{(R^2+R−pre[R])}_{只与R有关}+\\underbrace{(pre[L−1]−(L^2−L)) }_{只与L有关}求$\\Delta$的最大值即可\n怎么没写出来呢？\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e9 + 5;void solve()&#123;    int n;    cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1), pre(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; a[i];        pre[i] = pre[i - 1] + a[i];    &#125;    int mx1 = 0, mx2 = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        int x = pre[i - 1] - i * (i - 1);        mx1 = max(x, mx1);        x = i * (i + 1) - pre[i];        mx2 = max(x, mx2);    &#125;    cout &lt;&lt; pre[n] + mx1 + mx2 &lt;&lt; endl;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int _ = 1;    cin &gt;&gt; _;    while (_--)        solve();    return 0;&#125;\n这是错的，因为L要小于R，而我取了全局最大：\nint mx1 = 0, mx2 = 0;for (int i = 1; i &lt;= n; ++i) &#123;    int x = pre[i - 1] - i * (i - 1);    mx1 = max(x, mx1);    x = i * (i + 1) - pre[i];    mx2 = max(x, mx2);&#125;\n正解是：\nint mx = 0, ans = 0;for (int i = 1; i &lt;= n; ++i) &#123;    int x = pre[i - 1] - i * (i - 1);    mx = max(x, mx);    x = i * (i + 1) - pre[i] + mx;    ans = max(x, ans);&#125;\n 这样可以保证L&lt;=R\n妙啊\nAC码如下：#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e9 + 5;void solve()&#123;    int n;    cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1), pre(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; a[i];        pre[i] = pre[i - 1] + a[i];    &#125;    int mx = 0, ans = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        int x = pre[i - 1] - i * (i - 1);        mx = max(x, mx);        x = i * (i + 1) - pre[i] + mx;        ans = max(x, ans);    &#125;    cout &lt;&lt; pre[n] + ans &lt;&lt; endl;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int _ = 1;    cin &gt;&gt; _;    while (_--)        solve();    return 0;&#125;\n解法二对于任意区间 [L,R]：\n原区间和为：\n\\displaystyle\\sum_{i=L}^{R} a_i替换后的区间和： \nT = (R-L+1)(L+R)神奇的来了，注意到\nT = (R-L+1)(L+R) = 2  \\times  \\dfrac{(R-L+1)(L+R)}{2}这是什么？\n\\dfrac{(R-L+1)(L+R)}{2}这是等差序列的求和公式！：\n\n\n$$S_n = \\dfrac{{项数}\\times (\\text{首项} + \\text{末项})}{2}$$\n\n\n所以：\nT = 2  \\times  \\dfrac{(R-L+1)(L+R)}{2} =2 \\times (L+(L+1)+⋯+R)所以$T$也可以写成:\n\n\n$$\\displaystyle{2 \\times \\sum_{i=L}^{R}} i = \\displaystyle{ \\sum_{i=L}^{R}} 2i$$\n\n\n所以$\\Delta$可以写成:\n\n\n$$\\displaystyle{\\Delta = T - \\displaystyle\\sum_{i=L}^{R} a_i =  \\sum_{i=L}^{R} {(2i - a_i)}}$$\n\n\n于是问题简化成：寻找区间，使得 $\\displaystyle{\\Delta = \\sum_{i=L}^{R} {(2i - a_i)}}$ 最大\n这已经是标准最大子段和问题了\nAC码如下：#include&lt;bits/stdc++.h&gt;using namespace std;    const int N=1e9+5;    void solve()&#123;        int n; cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1), b(n + 1);     long long sum = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; a[i];        sum += a[i];        b[i] = 2 * i - a[i];    &#125;        long long ans = 0, tot = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        tot = max(0LL, tot + b[i]);        ans = max(tot, ans);    &#125;    cout &lt;&lt; ans + sum &lt;&lt; endl;&#125;    int main()&#123;        ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    cin&gt;&gt;_;    while(_--)    solve();    return 0;    &#125;\n","categories":["题解"],"tags":["C++"]},{"title":"Hello World","url":"/2025/12/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n"},{"title":"P1005","url":"/2025/12/15/P1004/","content":"二维dp的回溯以及四维dpP1005 NOIP 2007 提高组] 矩阵取数游戏 - 洛谷 \n这题我一开始用两次二维dp解，每次取最优路（类似贪心）。可是我不会dp回溯，于是有了以下题解：\n二维dp的回溯如下：\n void back(int x, int y) &#123;        if (x == 1 &amp;&amp; y == 1) &#123;        return;    &#125;    if (x &gt; 1 &amp;&amp; dp[x - 1][y] + a[x][y] == dp[x][y]) &#123;        back(x - 1, y);    &#125;    else if (y &gt; 1 &amp;&amp; dp[x][y - 1] + a[x][y] == dp[x][y]) &#123;        back(x, y - 1);    &#125;&#125;\n很好懂吧，因为每次dp取得都是到当前格的最大值，因此路径一定存在，一步步减回去就行。\n完整码如下：\n #include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;    const int N=1e9+5;int dp1[11][11], dp2[11][11];int a[11][11];void back(int x, int y) &#123;        if (x == 1 &amp;&amp; y == 1) &#123;        a[x][y] = 0;        return;    &#125;    if (x &gt; 1 &amp;&amp; dp1[x - 1][y] + a[x][y] == dp1[x][y]) &#123;        a[x][y] = 0;        back(x - 1, y);    &#125;    else if (y &gt; 1 &amp;&amp; dp1[x][y - 1] + a[x][y] == dp1[x][y]) &#123;        a[x][y] = 0;        back(x, y - 1);    &#125;&#125;void solve()&#123;        int n; cin &gt;&gt; n;    while(1) &#123;        int x, y, z;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        if (x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0) &#123;            break;        &#125;        else &#123;            a[x][y] = z;        &#125;    &#125;    int sum = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            dp1[i][j] = max(dp1[i - 1][j], dp1[i][j - 1]) + a[i][j];        &#125;    &#125;    sum += dp1[n][n];    back(n, n);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            dp2[i][j] = max(dp2[i - 1][j], dp2[i][j - 1]) + a[i][j];        &#125;    &#125;    sum += dp2[n][n];    cout &lt;&lt; sum &lt;&lt; endl;    &#125;    int main()&#123;        ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    return 0;    &#125;\n注意两点：\nvoid back(int x, int y) &#123;        //  a[x][y] = 0; 不要写在这里，a[x][y]后面会用到，这里不要先改，到if后面再改 !!!        if (x == 1 &amp;&amp; y == 1) &#123;        a[x][y] = 0;\t        return;    &#125;    if (x &gt; 1 &amp;&amp; dp1[x - 1][y] + a[x][y] == dp1[x][y]) &#123;\t// x &gt; 1 不要越界        a[x][y] = 0;        back(x - 1, y);    &#125;    else if (y &gt; 1 &amp;&amp; dp1[x][y - 1] + a[x][y] == dp1[x][y]) &#123;\t// 同理, y &gt; 1 不要越界        a[x][y] = 0;        back(x, y - 1);    &#125;&#125;\n果然pa了，因为当前最优不代表全局最优，贪心思路不可行，反例：\n71 2 21 3 32 2 33 2 35 4 46 4 47 2 27 4 40 0 0\n0 2 3 0 0 0 00 3 0 0 0 0 00 3 0 0 0 0 00 0 0 0 0 0 00 0 0 4 0 0 00 0 0 4 0 0 00 2 0 4 0 0 0\n答案是25，然而我的解法第一次是：\n0 0 3 0 0 0 00 0 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 0 00 2 0 0 0 0 0\n得20，第二次得23。\n实际上是第一次：\n0 0 3 0 0 0 00 0 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 0 00 0 0 4 0 0 00 0 0 4 0 0 00 0 0 0 0 0 0\n第二次全吞完，得25。\n所以得用四维dp做。\n四维dp直接上代码吧：\n #include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;    int dp[11][11][11][11]; // dp[i][j][p][q]表示第一遍走到点(i, j),第二遍走到点(p, q)的最优解int a[11][11];    void solve()&#123;        int n; cin &gt;&gt; n;    while(1) &#123;        int x, y, z;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        if (x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0) &#123;            break;        &#125;        else &#123;            a[x][y] = z;        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            for (int p = 1; p &lt;= n; ++p) &#123;                for (int q = 1; q &lt;= n; ++q) &#123;                    dp[i][j][p][q] = max(max(dp[i-1][j][p-1][q], dp[i-1][j][p][q-1]), max(dp[i][j-1][p-1][q], dp[i][j-1][p][q-1])) + a[i][j] + a[p][q];\t\t\t\t\tif (i == p &amp;&amp; j == q) dp[i][j][p][q] -= a[i][j];                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; dp[n][n][n][n] &lt;&lt; endl;    &#125;    int main()&#123;        ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    return 0;    &#125;\n","categories":["题解"],"tags":["C++"]},{"title":"位运算小技巧总结","url":"/2025/12/15/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","content":"位运算小技巧总结1. 奇偶性快速判断与反转// 判断奇偶性bool is_odd = x &amp; 1;  // 真为奇数，假为偶数// 0/1交替n ^= 1;\n2. 二进制位操作// (1) 取第k位（从0开始）int bit = (n &gt;&gt; k) &amp; 1;// (2) 设置第k位为1n |= (1 &lt;&lt; k);// (3) 设置第k位为0n &amp;= ~(1 &lt;&lt; k);\n3. 位遍历(判断当前位是 1 还是 0 )while(num) &#123;           // 当num不为0时循环    if(num &amp; 1) &#123;              // 当前位为1的处理逻辑     &#125;    else&#123;        // 当前位为0的处理逻辑    &#125;    num &gt;&gt;= 1;         // 右移一位（相当于除以2）&#125;\n4. 快速计算二进制1的个数（__builtin_popcount）int cnt = __builtin_popcount(x); // GCC内置函数// 等价于：int cnt = 0;while(x) &#123;    x &amp;= x - 1;  // 清除最低位的1    ++cnt;&#125;\n5. 保留最低位的1（lowbit）int lowbit = x &amp; -x;  // 树状数组核心操作// 例如：x=6(110) → 2(10)\n6. 判断/寻找0位int t = 1ll;for (int i = 0; i &lt;= 63;++i)&#123;    if(!(n&amp;t))&#123;     //核心判断条件        //n的第i位为0    &#125;    t &lt;&lt;= 1;&#125;\n7. 判断是否为2的幂bool is_power_of_two = (x &amp; (x - 1)) == 0;// 注意特判x=0时为false\n8. 位运算优先级口诀~ &gt; 算术运算 &gt; &lt;&lt; &gt;&gt; &gt; &amp; &gt; ^ &gt; |\n注意事项\n位运算优先级容易出错，建议多用括号\n右移时注意符号位（无符号用&gt;&gt;，有符号用&gt;&gt;&gt;）\n大数运算记得加1LL防止溢出\n\n","categories":["笔记"],"tags":["C++"]},{"title":"欧拉函数","url":"/2025/12/15/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","content":"欧拉函数 (Euler’s Totient Function) 详解欧拉函数 φ(n) 是数论中一个非常重要的函数，它表示小于或等于 n 的正整数中与 n 互质的数的个数。\n定义对于正整数 n，欧拉函数 φ(n) 定义为：φ(n) = 小于或等于 n 的正整数中与 n 互质的数的个数其中”互质”意味着两个数的最大公约数为1。\n计算方法1. 对于质数 p如果 p 是质数，那么：φ(p) = p - 1因为1,2,…,p-1都与p互质。\n2. 对于质数的幂 pᵏφ(pᵏ) = pᵏ - pᵏ⁻¹ = pᵏ(1 - 1/p)\n因为在1到pᵏ之间，只有p的倍数不与pᵏ互质，这样的数有pᵏ⁻¹个。\n3. 对于任意正整数 n利用中国剩余定理和积性函数性质，如果n的标准质因数分解为：n = p₁ᵏ¹ × p₂ᵏ² × ... × pₘᵏᵐ那么：φ(n) = n × (1 - 1/p₁) × (1 - 1/p₂) × ... × (1 - 1/pₘ)\n示例计算\nφ(10):\n10 = 2 × 5φ(10) = 10 × (1 - 1/2) × (1 - 1/5) = 10 × 1/2 × 4/5 = 4\n实际与10互质的数有1,3,7,9，共4个。\n\nφ(12):\n12 = 2² × 3φ(12) = 12 × (1 - 1/2) × (1 - 1/3) = 12 × 1/2 × 2/3 = 4\n实际与12互质的数有1,5,7,11，共4个。\n\n\n在代码中的应用在你提供的代码中，计算了φ(210):210 = 2 × 3 × 5 × 7φ(210) = 210 × (1 - 1/2) × (1 - 1/3) × (1 - 1/5) × (1 - 1/7)       = 210 × 1/2 × 2/3 × 4/5 × 6/7       = 48这意味着在每210个连续整数中，有48个数不被2,3,5,7整除（即与210互质）。\n性质\n积性函数：如果m和n互质，则φ(mn) = φ(m)φ(n)\n欧拉定理：如果a和n互质，则a^φ(n) ≡ 1 (mod n)\n费马小定理：当n是质数p时的特例，a^(p-1) ≡ 1 (mod p)\n\n欧拉函数在密码学（如RSA算法）、数论和组合数学中都有广泛应用。\n","categories":["笔记"],"tags":["C++"]},{"title":"CF2040C","url":"/2025/12/15/CF2040C/","content":"简单二进制状压 Problem - C - Codeforces \n打表：\n#include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;    const int N=1e9+5;    void solve()&#123;        ll n; cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1);    int ans = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        a[i] = i;        ans += i * (n - i + 1);    &#125;    int cnt = 0;    do &#123;        int sum = 0;        for (int i = 1; i &lt;= n; ++i) &#123;            int mn = 0x3f3f3f3f;            for (int j = i; j &lt;= n; ++j) &#123;                mn = min(mn, a[j]);                sum += mn;            &#125;        &#125;        if (sum == ans)&#123;            ++cnt;            cout &lt;&lt; &quot;\\033[0m&quot; &lt;&lt; cnt &lt;&lt; &quot;: &quot;;            for (int i = 1; i &lt;= n; ++i) &#123;                if (a[i] == 3)  cout &lt;&lt; &quot;\\033[32m&quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot;;                else cout &lt;&lt; &quot;\\033[31m&quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot;;            &#125;            cout &lt;&lt; endl;        &#125;    &#125;while(next_permutation(a.begin() + 1, a.end()));    &#125;    int main()&#123;        //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    system(&quot;pause&quot;);    return 0;    &#125;\n输入5为例:\n\n\n不难发现：一半1，一半1里有一半2，一半2里又有一半3…\n超过半数往后站，不过半往前站\n因此有解:\n#include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;void solve()&#123;        ll n, k; cin &gt;&gt; n &gt;&gt; k;    ll m = n;    vector&lt;int&gt; a(n + 1);    ll sum = 1LL;    for (int i = 1; i &lt; n; ++i) &#123;        sum &lt;&lt;= 1LL;        if (sum &gt;= 1e12) &#123;            sum = 1e12;            break;        &#125;    &#125;    if (k &gt; sum) &#123;        cout &lt;&lt; -1 &lt;&lt; endl;        return;    &#125;    int l = 1, r = n;    ll ls = 0LL, rs = sum;    for (int i = 1; i &lt;= n; ++i) &#123;        ll mid = ((ls + rs) &gt;&gt; 1LL);        if (k &lt;= mid) &#123;\t            a[l] = i;\t//不过半往前站            ++l;            rs = mid;\t//集中前半段        &#125;        else &#123;            a[r] = i;\t//超过半数往后站            --r;            ls = mid;\t//集中后半段        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    &#125;int main()&#123;        ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    cin&gt;&gt;_;    while(_--)    solve();    return 0;    &#125;\n但是，这么解是错的，让我们听听AI怎么说。\n对于\n输入：1 60 2 我输出的是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 40 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 39 正确答案是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 60 59  \n为什么错了？ \n你把 sum = 2^(n-1) 人为截断成 1e12。当 n=60 时真实的 $2^{n-1}=2^{59}≈5.76e17$，而你把它设成 1e12。以后你用 [ls,rs) 以二分区间把 k 映射成“左右选择”的逻辑 依赖 rs-ls 恰好是 2^(remaining) 的幂次。截断后这个不再成立，映射就被彻底破坏了 —— 因此决策在第 ~39 次才从“放左”变成“放右”，产生你看到的 1..38 然后一大段乱序的结果。 \n什么意思，原本sum很长很长，可以截很多个二分，但因为原本sum太长太长了，long long存不下，我把它截成 1e12（k的最大值），导致截的二分数变少了，mid很快扰乱了如下代码的判断\nfor (int i = 1; i &lt;= n; ++i) &#123;    ll mid = ((ls + rs) &gt;&gt; 1LL);    if (k &lt;= mid) &#123;\t        a[l] = i;\t//不过半往前站        ++l;        rs = mid;\t//集中前半段    &#125;    else &#123;        a[r] = i;\t//超过半数往后站        --r;        ls = mid;\t//集中后半段    &#125;&#125;\n不妨想一下：\n二进制状压我们这样打表：\n#include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;    const int N=1e9+5;    void solve()&#123;        ll n; cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1);    int ans = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        a[i] = i;        ans += i * (n - i + 1);    &#125;    int cnt = 0;    do &#123;        int sum = 0;        for (int i = 1; i &lt;= n; ++i) &#123;            int mn = 0x3f3f3f3f;            for (int j = i; j &lt;= n; ++j) &#123;                mn = min(mn, a[j]);                sum += mn;            &#125;        &#125;        if (sum == ans)&#123;            ++cnt;            cout &lt;&lt; &quot;\\033[0m&quot; &lt;&lt; bitset&lt;4&gt;(cnt - 1)&lt;&lt; &quot;: &quot;; //以5为例(0 ~ 15) 16种情况            for (int i = 1; i &lt;= n; ++i) &#123;                if (a[i] == 1)  cout &lt;&lt; &quot;\\033[32m&quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot;;                else cout &lt;&lt; &quot;\\033[31m&quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot;;            &#125;            cout &lt;&lt; endl;        &#125;    &#125;while(next_permutation(a.begin() + 1, a.end()));    &#125;    int main()&#123;        //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    system(&quot;pause&quot;);    return 0;    &#125;\n\n \n我们可以想到，我们之前的步骤中，每一次二分相当于消去最高位，观察下一位，如果该位是0，往前站，该位是1，往后站，最后剩下的一位，填最后一位（n）。\n假设n = 5, 当前位置为k = 8，由于从0计数，所以减1，得7，二进制为0111，于是，我们有：\n0111: 1 111: 1       2   11: 1     3 2   1: 1   4 3 2最后：1 5 4 3 2\n完美！\n我们可以反过来，从n到1填，毕竟从低位到高位遍历数位要容易很多，不断除2就行。填数就用双端队列一个个往里挤，很方便。\n代码如下：\n#include&lt;bits/stdc++.h&gt;using ll = long long;using namespace std;void solve()&#123;        ll n, k; cin &gt;&gt; n &gt;&gt; k;    ll m = n;    vector&lt;int&gt; a(n + 1);    ll sum = 1LL;    for (int i = 1; i &lt; n; ++i) &#123;        sum &lt;&lt;= 1LL;        if (sum &gt;= 1e12) &#123;            sum = 1e12;            break;        &#125;    &#125;    if (k &gt; sum) &#123;        cout &lt;&lt; -1 &lt;&lt; endl;        return;    &#125;        ll b = k - 1;\t//从0计数，减1    deque&lt;ll&gt; dq;    dq.push_back(n);    for (ll x = n - 1; x &gt;= 1; --x) &#123;        if (b &amp; 1LL) dq.push_back(x);        else dq.push_front(x);         b &gt;&gt;= 1;    &#125;    while(!dq.empty()) &#123;        cout &lt;&lt; dq.front() &lt;&lt; &quot; &quot;;        dq.pop_front();    &#125;    cout &lt;&lt; endl;    &#125;    int main()&#123;        ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    cin&gt;&gt;_;    while(_--)    solve();    return 0;    &#125;\nAC了！\n那你可能会想：前面说那么多，不还是观察出来的吗？\n是的。\n","categories":["题解"],"tags":["C++"]},{"title":"浮点二分和三分","url":"/2025/12/15/%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86%E5%92%8C%E4%B8%89%E5%88%86/","content":"https://ac.nowcoder.com/acm/contest/120454/F\n 属于典型的“是否存在一个 X ∈ R 可以满足所有约束”的问题 \n浮点二分二分解法： 二分答案$r^2$，然后将区间$x-\\sqrt{r^2-y^2}$到$x+\\sqrt{r^2-y^2}$ 区间覆盖判断，若所有区间存在交集，则返回true \n先看错解：\n#include&lt;bits/stdc++.h&gt;using namespace std;struct node &#123;    double x, y;&#125;; void solve()&#123;     int n; cin &gt;&gt; n;    vector&lt;node&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;    &#125;    auto check = [&amp;](double R2) -&gt; bool &#123;        double L = -1e9, R = 1e9;        for (int i = 1; i &lt;= n; ++i) &#123;            double X = R2 - a[i].y * a[i].y;            double l = a[i].x - sqrt(X);            double r = a[i].x + sqrt(X);            L = max(L, l);            R = min(R, r);        &#125;        return L &lt;= R;    &#125;;    double l = -1e9, r = 1e9;    double ans;    while (l &lt;= r) &#123;        double mid = l + (r - l) / 2.0;        if (check (mid)) &#123;            ans = mid;            l = mid + 1;        &#125;        else &#123;            r = mid - 1;        &#125;    &#125;    cout &lt;&lt; sqrt(ans) &lt;&lt; endl; &#125; int main()&#123;     ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    return 0; &#125;\n错误点：\n\n在二分一个 double，却使用了整数二分写法 \nwhile (l &lt;= r) &#123;    mid = l + (r - l) / 2;    if (check(mid)) l = mid + 1;    else r = mid - 1;&#125;\n使用这种比较完全不收敛，而且 mid + 1 会跳过正确答案，导致永远不精确。 \n\ncheck(R2) 没有边界判断 \n如果 $r^2$ &lt; $y^2$，$x^2$为负，会 sqrt(负数) → nan → WA/RE \n\n二分区间不应该是 [-1e9, 1e9] \n[-1e9, 1e9] 有一半是无效区间因为我们二分答案 $r^2$ ，而半径平方不能为负\n\n\n正确写法：浮点二分（模板）  double l = 0, r = 2e8;   // 1e4^2 + 1e4^2for (int i = 0; i &lt; 60; i++) &#123;    double mid = (l + r) / 2;    if (check(mid)) r = mid;    else l = mid;&#125;\n 不能用 while(l &lt;= r)！！ \n最终无 bug 版本#include&lt;bits/stdc++.h&gt;using namespace std;struct node &#123;    double x, y;&#125;; void solve()&#123;     int n; cin &gt;&gt; n;    vector&lt;node&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;    &#125;    auto check = [&amp;](double R2) -&gt; bool &#123;        double L = -1e9, R = 1e9;        for (int i = 1; i &lt;= n; ++i) &#123;            double X = R2 - a[i].y * a[i].y;            if (X &lt; 0) return 0;\t//若圆与x轴无交点，即X &lt; 0，直接返回false，否则sqrt(X)会nan                        double l = a[i].x - sqrt(X);            double r = a[i].x + sqrt(X);            L = max(L, l);            R = min(R, r);        &#125;        return L &lt;= R;    &#125;;        double l = 0, r = 1e9;    for (int i = 1; i &lt;= 60; ++i) &#123;        double mid = l + (r - l) / 2;        if (check(mid)) &#123;            r = mid;\t//这里应该以r为答案，之前连这里都错了！        &#125;        else &#123;            l = mid;        &#125;    &#125;        cout &lt;&lt; setprecision(6) &lt;&lt; sqrt(r) &lt;&lt; endl; &#125; int main()&#123;     ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    return 0; &#125;\n三分三分法是一种用于在“单峰/单谷函数f(x)”上寻找最优值（最大或最小）的算法。 \n三分法思想： 把区间 [l, r] 分成三段： l —— m1 —— m2 —— r\n 其中： m1 = l + (r - l) / 3 （左三等分点）            m2 = r - (r - l) / 3（右三等分点）\n 然后比较： f(m1) 和 f(m2)\n如果 f(m1) &lt; f(m2) → 最高点在区间 (m1, r) → 扔掉左边部分 l = m1\n如果 f(m1) &gt; f(m2) → 最高点在区间 (l, m2) → 扔掉右边部分 r = m2\n三分法代码模板（整数区间）int ternary(int l, int r) &#123;    while (r - l &gt;= 3) &#123;        int m1 = l + (r - l) / 3;        int m2 = r - (r - l) / 3;        if (f(m1) &lt; f(m2))             l = m1;        else             r = m2;    &#125;&#125;\n三分法代码模板（实数区间）double ternary(double l, double r) &#123;    const double eps = 1e-12;     while (r - l &gt; eps) &#123;        double m1 = l + (r - l) / 3;        double m2 = r - (r - l) / 3;        if (f(m1) &lt; f(m2)) &#123;            l = m1;        &#125; else &#123;            r = m2;        &#125;    &#125;&#125;\n算了，直接看题吧\n我们要在 x 轴上选一个点 X，使得到所有点 ($x_i$, $y_i$) 的 最大距离最小： \n$f(x) =  \\max\\limits_{1 \\le i \\le n}\\sqrt{(X - x_i)^2 + y_i^2}$\n自己感受一下：$X$从x轴左边到x轴右边，$\\max\\limits_{1 \\le i \\le n}\\sqrt{(X - x_i)^2 + y_i^2}$ 肯定先变小后变大\n所以这个函数 是凹的（单峰），我们要搜$f(x)$ 的最小值（对应$x$为X），因此可用 三分法 搜索 X。 \n代码（AC 版本，C++）#include&lt;bits/stdc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;void solve()&#123;        int n; cin &gt;&gt; n;    vector&lt;node&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;    &#125;    auto f = [&amp;](double x) -&gt; double &#123;        double mx = 0;        for (int i = 1; i &lt;= n; ++i) &#123;            double dx = a[i].x - x, dy = a[i].y;            mx = max(mx, sqrt(dx * dx + dy * dy));        &#125;        return mx;    &#125;;    double l = -10000, r = 10000;    for (int i = 1; i &lt;= 60; ++i) &#123;        double m1 = l + (r - l) / 3;        double m2 = r - (r - l) / 3;        if (f(m1) &gt; f(m2)) &#123;            l = m1;        &#125;        else &#123;            r = m2;        &#125;    &#125;    cout &lt;&lt; setprecision(6) &lt;&lt; f((l + r) / 2.0) &lt;&lt; endl;    &#125;    int main()&#123;    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);    int _=1;    while(_--)    solve();    return 0;    &#125;\n收工！\n","categories":["笔记"],"tags":["C++"]},{"title":"从逐次减法到高效除法","url":"/2025/12/15/%E4%BB%8E%E9%80%90%E6%AC%A1%E5%87%8F%E6%B3%95%E5%88%B0%E9%AB%98%E6%95%88%E9%99%A4%E6%B3%95/","content":"从逐次减法到高效除法题目描述：给定初始值 N，以及 M 种操作，每种操作 (a, b)，表示每次操作必须满足 N &gt;= a，然后 N 会减少 b。要求计算最多可以执行多少次操作，并更新 N。\n\n思路与推导：\n操作描述：每个操作 (a, b)，表示：\n\n只有当 N &gt;= a 时，才能进行操作。\n每次操作会将 N 减去 b，直到无法继续执行为止。\n\n\n最大操作次数的推导：假设对于某个操作 a 和 b，我们希望计算最多可以执行多少次该操作。\n由于每次操作将 N 减少 b，为了保证 N 始终大于等于 a，我们可以得到以下条件：\n\nN - t \\cdot b \\geq a其中 t 为最大执行次数。由此可以得到：\n\nt \\leq \\frac{N - a}{b}这意味着最多可以进行 $t = \\left\\lfloor \\frac{N - a}{b} \\right\\rfloor$ 次操作。\n为什么要加 1？\n\n因为N在减了t次之后还是大于或等于a的\nN - t \\cdot b \\geq a还可以再进行一次操作,这次减了b了之后,N小于a,不会再进行下一次(a,b)操作了\n\n所以，最终的最大操作次数是：\n\nt = \\left\\lfloor \\frac{N - a}{b} \\right\\rfloor + 1\n更新 N：每次操作执行 t 次后，N 会减少 t * b。更新后的 N 为：\n\nN = N - t \\cdot b继续进行下一个操作，直到遍历所有操作。\n\n\n\n示例：输入：100 220 350 5\n输出：27\n解释：\n第一个操作：a = 20, b = 3，计算 (100 - 20) / 3 + 1 = 27，执行 27 次，更新 N = 100 - 27 * 3 = 19。\n第二个操作：a = 50, b = 5，由于 N = 19 小于 50，跳过该操作。\n最终输出 cnt = 27。\n\n\n总结：通过优化循环，使用数学公式一次性计算每个操作的最大执行次数，避免了逐次减法，从而提高了程序效率。核心考察了通过数学推导解决动态问题和优化计算时间的能力。\n","categories":["笔记"],"tags":["C++"]},{"title":"位运算小技巧总结","url":"/2025/12/15/%E9%80%86%E5%90%91%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87/","content":"逆推概率笔记一、背景\n题目目标：计算多个区间随机出现时，每个格子恰好被一个区间覆盖的总概率。\n简化版本：去掉取模、逆元，用浮点数 p/q 表示区间出现概率。\n\n二、核心流程\n初始化 “都不出现” 的概率乘积（ans）\n\n每条区间不出现概率 = (q - p)/q\nans = ∏ (q - p)/q\n\n\n动态规划 (DP)\n\n状态：dp[i] 表示从格子 1 到 i，在“都不出现”的前提下，恰好被覆盖一次的概率。\n初始：dp[0] = 1，dp[1..m] = 0\n\n\n区间排序与转移\n\n先按 l、r 排序区间。\n对第 i 条区间 [l, r] 做：\ndp[r] += dp[l - 1] * (p / (q - p));\n\n\n结果计算\n\n最终答案 = ans * dp[m]\n\n\n\n三、关键疑问与解答问题1：为什么要除以 (q - p)？\n直觉误区：在“不出现”情况下，出现概率似乎为 0。\n条件概率：反向推导就是在“不出现”的条件下，推导“出现”的修正因子。\n公式推导：$P(出现|不出现) = \\frac{P(出现)}{P(不出现)} = \\frac{(p/q)}{((q-p)/q)} = \\frac{p}{q - p}.$\n\n问题2：什么是“反向推导”？\n指在“都不出现”的概率空间中，逆向演算某条区间突然出现对最终结果的影响。\n作用：给 dp 转移添加正确的概率修正因子。\n\n四、小例子演示\nm = 3, 区间 A:[1,2], p/q=1/2; B:[3,3], p/q=1/3\nans = (1/2)*(2/3) = 1/3\nDP 转移：\n\nA: dp[2] += dp[0] * (1/(2-1)) = 1  ⇒ dp[2] = 1\nB: dp[3] += dp[2] * (1/(3-1)) = 1/2 ⇒ dp[3] = 0.5\n\n\n最终：ans * dp[3] = 1/3 * 1/2 = 1/6\n\n五、简化版代码（去模版、取模、快速幂）#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Node &#123;    double l, r, p, q;&#125;;bool cmp(Node a, Node b) &#123;    if (a.l == b.l) return a.r &lt; b.r;    return a.l &lt; b.l;&#125;int main() &#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;Node&gt; seg(n);    double ans = 1.0;    for (int i = 0; i &lt; n; ++i) &#123;        cin &gt;&gt; seg[i].l &gt;&gt; seg[i].r &gt;&gt; seg[i].p &gt;&gt; seg[i].q;        ans *= (seg[i].q - seg[i].p) / seg[i].q;    &#125;    sort(seg.begin(), seg.end(), cmp);    vector&lt;double&gt; dp(m + 5, 0);    dp[0] = 1.0;    for (int i = 0; i &lt; n; ++i) &#123;        dp[(int)seg[i].r] += dp[(int)seg[i].l - 1] * seg[i].p / (seg[i].q - seg[i].p);    &#125;    cout &lt;&lt; ans * dp[m] &lt;&lt; endl;    return 0;&#125;\n\n备注：以上笔记可帮助队友快速理解“为什么除以 (q-p)”及反向推导思路。\n六、示意图解起点 dp[0] = 1.0  |  +-- 区间 A [1,2]       p/q = 1/2，不出现概率 (q-p)/q=1/2       修正因子 p/(q-p)=1/(2-1)=1       =&gt; dp[2] += dp[0] * 1 = 1.0             |             +-- 区间 B [3,3]                  p/q = 1/3，不出现概率 (q-p)/q=2/3                  修正因子 p/(q-p)=1/(3-1)=1/2                  =&gt; dp[3] += dp[2] * 1/2 = 0.5最终答案 = ans * dp[3] = (1/2*2/3) * 0.5 = 1/6\n","categories":["笔记"],"tags":["C++"]}]